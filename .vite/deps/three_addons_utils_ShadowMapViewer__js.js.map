{
  "version": 3,
  "sources": ["../../node_modules/three/examples/jsm/shaders/UnpackDepthRGBAShader.js", "../../node_modules/three/examples/jsm/utils/ShadowMapViewer.js"],
  "sourcesContent": ["/**\n * Unpack RGBA depth shader\n * - show RGBA encoded depth as monochrome color\n */\n\nconst UnpackDepthRGBAShader = {\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'opacity': { value: 1.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\n\t\t\tgl_FragColor = vec4( vec3( depth ), opacity );\n\n\t\t}`\n\n};\n\nexport { UnpackDepthRGBAShader };\n", "import {\n\tDoubleSide,\n\tLinearFilter,\n\tMesh,\n\tMeshBasicMaterial,\n\tOrthographicCamera,\n\tPlaneGeometry,\n\tScene,\n\tShaderMaterial,\n\tTexture,\n\tUniformsUtils\n} from 'three';\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\n\n/**\n * This is a helper for visualising a given light's shadow map.\n * It works for shadow casting lights: DirectionalLight and SpotLight.\n * It renders out the shadow map and displays it on a HUD.\n *\n * Example usage:\n *\t1) Import ShadowMapViewer into your app.\n *\n *\t2) Create a shadow casting light and name it optionally:\n *\t\tlet light = new DirectionalLight( 0xffffff, 1 );\n *\t\tlight.castShadow = true;\n *\t\tlight.name = 'Sun';\n *\n *\t3) Create a shadow map viewer for that light and set its size and position optionally:\n *\t\tlet shadowMapViewer = new ShadowMapViewer( light );\n *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\n *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\n *\n *\t4) Render the shadow map viewer in your render loop:\n *\t\tshadowMapViewer.render( renderer );\n *\n *\t5) Optionally: Update the shadow map viewer on window resize:\n *\t\tshadowMapViewer.updateForWindowResize();\n *\n *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\n */\n\nclass ShadowMapViewer {\n\n\tconstructor( light ) {\n\n\t\t//- Internals\n\t\tconst scope = this;\n\t\tconst doRenderLabel = ( light.name !== undefined && light.name !== '' );\n\t\tlet userAutoClearSetting;\n\n\t\t//Holds the initial position and dimension of the HUD\n\t\tconst frame = {\n\t\t\tx: 10,\n\t\t\ty: 10,\n\t\t\twidth: 256,\n\t\t\theight: 256\n\t\t};\n\n\t\tconst camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 10 );\n\t\tcamera.position.set( 0, 0, 2 );\n\t\tconst scene = new Scene();\n\n\t\t//HUD for shadow map\n\t\tconst shader = UnpackDepthRGBAShader;\n\n\t\tconst uniforms = UniformsUtils.clone( shader.uniforms );\n\t\tconst material = new ShaderMaterial( {\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\t\t} );\n\t\tconst plane = new PlaneGeometry( frame.width, frame.height );\n\t\tconst mesh = new Mesh( plane, material );\n\n\t\tscene.add( mesh );\n\n\n\t\t//Label for light's name\n\t\tlet labelCanvas, labelMesh;\n\n\t\tif ( doRenderLabel ) {\n\n\t\t\tlabelCanvas = document.createElement( 'canvas' );\n\n\t\t\tconst context = labelCanvas.getContext( '2d' );\n\t\t\tcontext.font = 'Bold 20px Arial';\n\n\t\t\tconst labelWidth = context.measureText( light.name ).width;\n\t\t\tlabelCanvas.width = labelWidth;\n\t\t\tlabelCanvas.height = 25;\t//25 to account for g, p, etc.\n\n\t\t\tcontext.font = 'Bold 20px Arial';\n\t\t\tcontext.fillStyle = 'rgba( 255, 0, 0, 1 )';\n\t\t\tcontext.fillText( light.name, 0, 20 );\n\n\t\t\tconst labelTexture = new Texture( labelCanvas );\n\t\t\tlabelTexture.magFilter = LinearFilter;\n\t\t\tlabelTexture.minFilter = LinearFilter;\n\t\t\tlabelTexture.needsUpdate = true;\n\n\t\t\tconst labelMaterial = new MeshBasicMaterial( { map: labelTexture, side: DoubleSide } );\n\t\t\tlabelMaterial.transparent = true;\n\n\t\t\tconst labelPlane = new PlaneGeometry( labelCanvas.width, labelCanvas.height );\n\t\t\tlabelMesh = new Mesh( labelPlane, labelMaterial );\n\n\t\t\tscene.add( labelMesh );\n\n\t\t}\n\n\n\t\tfunction resetPosition() {\n\n\t\t\tscope.position.set( scope.position.x, scope.position.y );\n\n\t\t}\n\n\t\t//- API\n\t\t// Set to false to disable displaying this shadow map\n\t\tthis.enabled = true;\n\n\t\t// Set the size of the displayed shadow map on the HUD\n\t\tthis.size = {\n\t\t\twidth: frame.width,\n\t\t\theight: frame.height,\n\t\t\tset: function ( width, height ) {\n\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tmesh.scale.set( this.width / frame.width, this.height / frame.height, 1 );\n\n\t\t\t\t//Reset the position as it is off when we scale stuff\n\t\t\t\tresetPosition();\n\n\t\t\t}\n\t\t};\n\n\t\t// Set the position of the displayed shadow map on the HUD\n\t\tthis.position = {\n\t\t\tx: frame.x,\n\t\t\ty: frame.y,\n\t\t\tset: function ( x, y ) {\n\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\n\t\t\t\tconst width = scope.size.width;\n\t\t\t\tconst height = scope.size.height;\n\n\t\t\t\tmesh.position.set( - window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0 );\n\n\t\t\t\tif ( doRenderLabel ) labelMesh.position.set( mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0 );\n\n\t\t\t}\n\t\t};\n\n\t\tthis.render = function ( renderer ) {\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\t//Because a light's .shadowMap is only initialised after the first render pass\n\t\t\t\t//we have to make sure the correct map is sent into the shader, otherwise we\n\t\t\t\t//always end up with the scene's first added shadow casting light's shadowMap\n\t\t\t\t//in the shader\n\t\t\t\t//See: https://github.com/mrdoob/three.js/issues/5932\n\t\t\t\tuniforms.tDiffuse.value = light.shadow.map.texture;\n\n\t\t\t\tuserAutoClearSetting = renderer.autoClear;\n\t\t\t\trenderer.autoClear = false; // To allow render overlay\n\t\t\t\trenderer.clearDepth();\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\trenderer.autoClear = userAutoClearSetting;\t//Restore user's setting\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.updateForWindowResize = function () {\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\t camera.left = window.innerWidth / - 2;\n\t\t\t\t camera.right = window.innerWidth / 2;\n\t\t\t\t camera.top = window.innerHeight / 2;\n\t\t\t\t camera.bottom = window.innerHeight / - 2;\n\t\t\t\t camera.updateProjectionMatrix();\n\n\t\t\t\t this.update();\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.update = function () {\n\n\t\t\tthis.position.set( this.position.x, this.position.y );\n\t\t\tthis.size.set( this.size.width, this.size.height );\n\n\t\t};\n\n\t\t//Force an update to set position/size\n\t\tthis.update();\n\n\t}\n\n}\n\n\nexport { ShadowMapViewer };\n"],
  "mappings": "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",
  "names": []
}
